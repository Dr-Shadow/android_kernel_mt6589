/************************************************************************************** File: - mediatek\custom\common\kernel\touchpanel\synaptics\synaptics_tm1347_i2c_rmi.c** OPPO_R819** Copyright (C), 2008-2012, OPPO Mobile Comm Corp., Ltd** ** Description:  **      touch panel driver for synaptics**      can change MAX_POINT_NUM value to support multipoint** Version: 1.0** Date created: 10:49:46,18/01/2012** Author: Yixue.Ge@BasicDrv.TP** ** --------------------------- Revision History: --------------------------------** 	<author>	<data>			<desc>** Yixue.Ge@BasicDrv.TP 14/02/2012 add some 11091 code** Yongjun.Wu@BasicDrv.TP 04/06/2012 modify for tp power reset pin** Yongjun.Wu@BasicDrv.TP 30/06/2012 modify driver adapt deferent firmware ************************************************************************************/#include <linux/module.h>#include <linux/kernel.h>#include <linux/delay.h>#include <linux/earlysuspend.h>#include <linux/hrtimer.h>#include <linux/i2c.h>#include <linux/input.h>#include <linux/interrupt.h>#include <linux/io.h>#include <linux/platform_device.h>#include <linux/slab.h>#include <linux/proc_fs.h>#include <linux/fs.h>#include <asm/uaccess.h>#include <mach/mt_pm_ldo.h>#include <mach/mt_gpio.h>//#include <mach/mt_devs.h>#include <mach/mt_typedefs.h>#include <mach/mt_boot.h>#include <mach/eint.h>#include <mach/mt_boot.h>#include <cust_eint.h>#include <linux/kthread.h>#include <mach/eint.h>#include <cust_eint.h>#include <linux/rtpm_prio.h>#include <linux/sysfs.h>#include "SynaFirmwareImage_3202.h"#include "synaptics_s3202_tpk.h"#include <linux/oppo_devices_list.h>#ifndef TPD_NO_GPIO #include "cust_gpio_usage.h"#endif#include <linux/proc_fs.h>#define TPD_DEVICE "mtk-tpd3202"#define TOUCHPANEL_INT_PIN 124#define  CUST_EINT_TOUCH_PANEL_NUM 5static unsigned int tp_debug = 1;#define TPD_DEBUG(a,arg...)\	do{\		if(tp_debug)\			printk(TPD_DEVICE ": " a,##arg);\	}while(0)	static struct workqueue_struct *synaptics_wq = NULL;static struct proc_dir_entry *prEntry = NULL; static struct proc_dir_entry *prEntry_double = NULL; static unsigned int boot_mode = 0;static unsigned int is_suspend = 0;static DEFINE_SEMAPHORE(work_sem);static int read_gusture = 0;static int get_tp_id(void);extern unsigned int lm3528_check_tpsuspend;extern TP_DEV tp_dev;extern int TP_FW;//static int tp_dev;//static int TP_FW;//#define TP_TRULY 1//#define TP_YOUNGFAST 0#define TP_TEST_PASS 1#define TP_TEST_FAIL 0#define TPDTM_DMESG(a,arg...) printk(TPD_DEVICE "(tm1347): " a,##arg)#define SYNAPTICS_NAME       "synaptics-tm1347"#define TRULY_FIRMWARE_ID  0x30303032#define YF_FW_LIMIT        0x30303532#define YF_FIRMWARE_ID    0x30303535#define SUPPORT_GUSTURE#ifdef SUPPORT_GUSTURE	static atomic_t double_tap_number;	static atomic_t double_tap_enable;	static atomic_t circle_gesture_number;	static atomic_t circle_gesture_enable;	static atomic_t	gusture_enable;	#define KEY_POWER 116#endif#ifdef CONFIG_HAS_EARLYSUSPENDstatic void synaptics_ts_early_suspend(struct early_suspend *h);static void synaptics_ts_late_resume(struct early_suspend *h);#endif#ifndef OPPO_R819//Fuchun.Liao@wxkfDrv,2013/05/31,add for solve compile errorint whether_in_call_state=0;int whether_in_approach_state=0;int L3G4200D_OpenGyro_preview(void){    return 0;}int L3G4200D_CloseGyro_preview(void){   return 0;}int L3G4200D_ReadGyroData_preview(char *buf){   return 0;}#endif static unsigned short SynaF34DataBase;static unsigned short SynaF34QueryBase;static unsigned short SynaF01DataBase;static unsigned short SynaF01CommandBase;static unsigned short SynaF34Reflash_BlockNum;static unsigned short SynaF34Reflash_BlockData;static unsigned short SynaF34ReflashQuery_BootID;static unsigned short SynaF34ReflashQuery_FlashPropertyQuery;static unsigned short SynaF34ReflashQuery_FirmwareBlockSize;static unsigned short SynaF34ReflashQuery_FirmwareBlockCount;static unsigned short SynaF34ReflashQuery_ConfigBlockSize;static unsigned short SynaF34ReflashQuery_ConfigBlockCount;static unsigned short SynaFirmwareBlockSize;static unsigned short SynaFirmwareBlockCount;static unsigned long SynaImageSize;static unsigned short SynaConfigBlockSize;static unsigned short SynaConfigBlockCount;static unsigned long SynaConfigImageSize;static unsigned short SynaBootloadID;static unsigned short SynaF34_FlashControl;static unsigned char *SynafirmwareImgData;static unsigned char *SynaconfigImgData;static unsigned char *SynalockImgData;static unsigned int SynafirmwareImgVersion;	static int F11_2D_QUERY_BASE;static int F11_2D_CMD_BASE;static int F11_2D_CTRL_BASE;static int F11_2D_DATA_BASE;static int F01_RMI_QUERY_BASE;static int F01_RMI_CMD_BASE;static int F01_RMI_CTRL_BASE;static int F01_RMI_DATA_BASE;static int F34_FLASH_QUERY_BASE;static int F34_FLASH_CMD_BASE;static int F34_FLASH_CTRL_BASE;static int F34_FLASH_DATA_BASE;static int F01_RMI_QUERY11;static int F01_RMI_CTRL00;static int F11_2D_CTRL00;static int F01_RMI_CTRL01;static int F11_2D_CTRL06;static int F11_2D_CTRL08;static int F11_2D_CTRL32;static int F11_2D_DATA01;static int F11_2D_CMD00;static int F01_RMI_CMD00;static int F34_FLASH_CTRL00;static int F54_ANALOG_QUERY_BASE;//0x73static int F54_ANALOG_COMMAND_BASE;//0x72static int F54_ANALOG_CONTROL_BASE;//0x0dstatic int F54_ANALOG_DATA_BASE;//0x00//extern void update_lcd();#define VKNUMBER 3static int max_x = 0;static int max_y = 0;static int tpd_keys[VKNUMBER][5] = {	{KEY_MENU,90, 2050,180,100},	{KEY_HOME,500,2050,180,100},	{KEY_BACK,855,2050,180,100},	};static int tpd_keys1[VKNUMBER][5] ={	{KEY_MENU,120,1830,92,60},	{KEY_HOME,507,1830,90,60},	{KEY_BACK,885,1830,90,60},	};#define MAX_POINT_NUM      10//must <=10struct point_info {    int x;    int raw_x;    int y;    int raw_y;    int z;};//typedef struct point_info points[MAX_POINT_NUM];struct synaptics_ts_data {	struct i2c_client *client;	struct input_dev *input_dev;		struct input_dev *kpd;	int use_irq;	struct hrtimer timer;	struct work_struct  work;    uint32_t pre_finger_state;	uint32_t max_x;    uint32_t max_y;	uint32_t flags;	uint32_t btn_state;	struct early_suspend early_suspend;};//extern struct TP_AUTOTEST *tp_autotest;static ssize_t cap_vk_show(struct kobject *kobj, struct kobj_attribute *attr,			char *buf){      /* LEFT: search: CENTER: menu ,home:search 412, RIGHT: BACK */      return sprintf(buf,        	__stringify(EV_KEY) ":" __stringify(KEY_MENU)   ":130:1424:140:226"         ":" __stringify(EV_KEY) ":" __stringify(KEY_HOME)   ":360:1424:140:226"         ":" __stringify(EV_KEY) ":" __stringify(KEY_BACK)   ":600:1424:140:226"         "\n");}static struct kobj_attribute mtk_virtual_keys_attr = {    .attr = {        .name = "virtualkeys.mtk-tpd3202",        .mode = S_IRUGO,    },    .show = &cap_vk_show,};static struct attribute *mtk_properties_attrs[] = {    &mtk_virtual_keys_attr.attr,    NULL};static struct attribute_group mtk_properties_attr_group = {    .attrs = mtk_properties_attrs,};struct kobject *syna_properties_kobj;static int synaptics_tpd_button_init(struct synaptics_ts_data *ts){	int ret = 0;    int i = 0;		ts->kpd = input_allocate_device();    	if (ts->kpd == NULL) 	{		ret = -ENOMEM;		printk(KERN_ERR "synaptics_tpd_button_init: Failed to allocate input device\n");		goto err_input_dev_alloc_failed;	}	ts->kpd->name = TPD_DEVICE "-kpd";    set_bit(EV_KEY, ts->kpd->evbit);	__set_bit(KEY_MENU, ts->kpd->keybit);	__set_bit(KEY_HOME, ts->kpd->keybit);	__set_bit(KEY_BACK, ts->kpd->keybit);	ts->kpd->id.bustype = BUS_HOST;    ts->kpd->id.vendor  = 0x0001;    ts->kpd->id.product = 0x0001;    ts->kpd->id.version = 0x0100;		if(input_register_device(ts->kpd))        TPDTM_DMESG("input_register_device failed.(kpd)\n");    set_bit(EV_KEY, ts->kpd->evbit);	__set_bit(KEY_MENU, ts->kpd->keybit);	__set_bit(KEY_HOME, ts->kpd->keybit);	__set_bit(KEY_BACK, ts->kpd->keybit);	    syna_properties_kobj = kobject_create_and_add("board_properties", NULL);    if(syna_properties_kobj)        ret = sysfs_create_group(syna_properties_kobj,&mtk_properties_attr_group);    if(!syna_properties_kobj || ret)    printk("failed to create board_properties\n");			err_input_dev_alloc_failed:		    return ret;}static int synaptics_probe(struct platform_device *pdev);static int synaptics_remove(struct platform_device *pdev);static struct platform_driver synaptics_driver = {    .remove     = synaptics_remove,    //.shutdown   = NULL,    .probe      = synaptics_probe,    //#ifndef CONFIG_HAS_EARLYSUSPEND    //.suspend    = NULL,    //.resume     = NULL,   // #endif    .driver     = {    //	.owner = THIS_MODULE,        .name = "synaptics-platform",    },};#define TPD_USE_EINT#ifdef TPD_USE_EINT/*#ifndef CUST_EINT_TOUCH_PANEL_NUM#define TOUCHPANEL_INT_PIN GPIO1#define CUST_EINT_TOUCH_PANEL_NUM              2#define CUST_EINT_TOUCH_PANEL_DEBOUNCE_CN      0x0#define CUST_EINT_TOUCH_PANEL_POLARITY         CUST_EINT_POLARITY_HIGH#define CUST_EINT_TOUCH_PANEL_SENSITIVE        CUST_EINT_EDGE_SENSITIVE#define CUST_EINT_TOUCH_PANEL_DEBOUNCE_EN   CUST_EINT_DEBOUNCE_DISABLE#else#define TOUCHPANEL_INT_PIN GPIO_CTP_EINT_PIN#endif*/#define TOUCHPANEL_INT_PIN GPIO75#endifstatic void tpd_down(struct synaptics_ts_data *ts,    int raw_x, int raw_y, int x, int y, int p) {    if(ts && ts->input_dev) {        input_report_key(ts->input_dev, BTN_TOUCH, 1);        input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, p);        input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, (raw_x+raw_y)/2);        input_report_abs(ts->input_dev, ABS_MT_POSITION_X, x);        input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, y);        input_mt_sync(ts->input_dev);        TPD_DEBUG("D[%4d %4d %4d]\n", x, y, p);    }  }static void tpd_up(struct synaptics_ts_data *ts,    int raw_x, int raw_y, int x, int y, int p) {	 if(ts && ts->input_dev) {       // input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, p);       // input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, (raw_x+raw_y)/2);       // input_report_abs(ts->input_dev, ABS_MT_POSITION_X, x);        //input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, y);         input_report_key(ts->input_dev, BTN_TOUCH, 0);        input_mt_sync(ts->input_dev);        TPD_DEBUG("U[%4d %4d %4d]\n", x, y, 0);    }  }static void tpd_button(struct synaptics_ts_data *ts,    unsigned int x, unsigned int y, unsigned int down) {    int i;	if(max_x == 1145)	{	    if(down) {	        for(i=0;i<VKNUMBER;i++) {	            if(x>=tpd_keys[i][1]&&	               x<=tpd_keys[i][1]+tpd_keys[i][3] &&	               y>=tpd_keys[i][2]&&	               y<=tpd_keys[i][2]+tpd_keys[i][4]&&	               !(ts->btn_state&(1<<i))) {	                input_report_key(ts->input_dev, tpd_keys[i][0], 1);	                ts->btn_state|=(1<<i);	            }	        }	    } else {	        for(i=0;i<4;i++) {	            if(ts->btn_state&(1<<i)) {	                input_report_key(ts->input_dev, tpd_keys[i][0], 0);	            }	        }	        ts->btn_state=0;	    }	}else{	    if(down) {	        for(i=0;i<VKNUMBER;i++) {	            if(x>=tpd_keys1[i][1]&&	               x<=tpd_keys1[i][1]+tpd_keys1[i][3] &&	               y>=tpd_keys1[i][2]&&	               y<=tpd_keys1[i][2]+tpd_keys1[i][4]&&	               !(ts->btn_state&(1<<i))) {	                input_report_key(ts->input_dev, tpd_keys1[i][0], 1);	                ts->btn_state|=(1<<i);	            }	        }	    } else {	        for(i=0;i<4;i++) {	            if(ts->btn_state&(1<<i)) {	                input_report_key(ts->input_dev, tpd_keys1[i][0], 0);	            }	        }	        ts->btn_state=0;    }	}}static void tpd_hw_pwron(void){    hwPowerOn(MT65XX_POWER_LDO_VGP5,VOL_2800,"CTP");	msleep(1);    hwPowerOn(MT65XX_POWER_LDO_VGP4,VOL_1800,"CTP");	msleep(250);//hsy@oppo.com, add 2011/9/9 to speed up screen resume}static void tpd_hw_pwroff(void){	hwPowerDown(MT65XX_POWER_LDO_VGP4,"TP");	msleep(1);    hwPowerDown(MT65XX_POWER_LDO_VGP5,"TP");}static void tpd_power(unsigned int on){				if(on)			{				tpd_hw_pwron();			}			else			{				tpd_hw_pwroff();			}		}static int synaptics_read_register_map(struct synaptics_ts_data *ts){   uint8_t buf[4];      int ret;	memset(buf, 0, sizeof(buf));   	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x0); 	if (ret < 0) {		TPD_DEBUG("synaptics_read_register_map: failed for page select\n");		return -1;		}	ret = i2c_smbus_read_i2c_block_data(ts->client, 0xDD, 4, &(buf[0x0]));    F11_2D_QUERY_BASE = buf[0];	F11_2D_CMD_BASE = buf[1];	F11_2D_CTRL_BASE = buf[2]; 	F11_2D_DATA_BASE = buf[3];	    TPD_DEBUG("F11_2D_QUERY_BASE = %x \n \		F11_2D_CMD_BASE  = %x \n\		   F11_2D_CTRL_BASE	= %x \n\		   F11_2D_DATA_BASE	= %x \n\		   ",F11_2D_QUERY_BASE,F11_2D_CMD_BASE,F11_2D_CTRL_BASE,F11_2D_DATA_BASE);		ret = i2c_smbus_read_i2c_block_data(ts->client, 0xE3, 4, &(buf[0x0]));    	F01_RMI_QUERY_BASE = buf[0];	F01_RMI_CMD_BASE = buf[1];	F01_RMI_CTRL_BASE = buf[2]; 	F01_RMI_DATA_BASE = buf[3];    TPD_DEBUG("F01_RMI_QUERY_BASE = %x \n\          F01_RMI_CMD_BASE  = %x \n\		    F01_RMI_CTRL_BASE	= %x \n\		    F01_RMI_DATA_BASE	= %x \n\		   ",F01_RMI_QUERY_BASE,F01_RMI_CMD_BASE,F01_RMI_CTRL_BASE,F01_RMI_DATA_BASE);	ret = i2c_smbus_read_i2c_block_data(ts->client, 0xE9, 4, &(buf[0x0]));	  		F34_FLASH_QUERY_BASE = buf[0];		F34_FLASH_CMD_BASE = buf[1];		F34_FLASH_CTRL_BASE = buf[2]; 		F34_FLASH_DATA_BASE = buf[3];		TPD_DEBUG("F34_FLASH_QUERY_BASE = %x \n\			  F34_FLASH_CMD_BASE	= %x \n\				F34_FLASH_CTRL_BASE	= %x \n\				F34_FLASH_DATA_BASE	= %x \n\			   ",F34_FLASH_QUERY_BASE,F34_FLASH_CMD_BASE,F34_FLASH_CTRL_BASE,F34_FLASH_DATA_BASE);			F01_RMI_QUERY11 = F11_2D_QUERY_BASE+11;		F01_RMI_CTRL00 = F01_RMI_CTRL_BASE;		F11_2D_CTRL00 = F11_2D_CTRL_BASE;		F01_RMI_CTRL01 = F01_RMI_CTRL_BASE + 1;		F11_2D_CTRL06 = F11_2D_CTRL_BASE + 6;		F11_2D_CTRL08 = F11_2D_CTRL_BASE + 8;		F11_2D_CTRL32 = F11_2D_CTRL_BASE + 15;		F11_2D_DATA01 = F11_2D_DATA_BASE + 2;		F11_2D_CMD00 = F11_2D_CMD_BASE;		F01_RMI_CMD00 = F01_RMI_CMD_BASE;		F34_FLASH_CTRL00 = F34_FLASH_CTRL_BASE;}#ifdef SUPPORT_GUSTUREstatic int synaptics_enable_interrupt_for_gusture(struct synaptics_ts_data *ts,    int enable){	int ret;	uint8_t status_int;	uint8_t abs_status_int;    /* page select = 0x0 */	printk("synaptics_enable_interrupt_for_gusture is called\n");	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x0); 	if(ret < 0) {				TPD_DEBUG("synaptics_enable_interrupt_for_gusture: select page failed ret = %d\n",		    ret);		return -1;	}	ret = i2c_smbus_read_byte_data(ts->client, F11_2D_CTRL00);	if(ret < 0) {		TPD_DEBUG("read reg F11_2D_CTRL00 failed\n");		return -1;	}//1.enable the gusture fuction/*		ret = i2c_smbus_write_byte_data(ts->client,0xff,0x04);			if(ret < 0) {					TPD_DEBUG("page select failed\n");				}		if(enable)			{				ret = i2c_smbus_write_byte_data(ts->client,0x04,0x01);				if(ret < 0) {					TPD_DEBUG("read 0x2C failed\n");				}			} 		else						{				ret = i2c_smbus_write_byte_data(ts->client,0x04,0x00);				if(ret < 0) {					TPD_DEBUG("read 0x2C failed\n");				}			}		printk("the num of 0x0404 for the 4page is %x\n",i2c_smbus_read_byte_data(ts->client,0x04));		ret = i2c_smbus_write_byte_data(ts->client,0xff,0x00);*///enable or disable over.....					if(enable) {				status_int = (ret & 0xF8) | 0x04;				/*clear interrupt bits for previous touch*/		ret = i2c_smbus_read_byte_data(ts->client, 0x14);		if(ret < 0) {			TPD_DEBUG("synaptics_enable_interrupt :clear interrupt bits failed\n");			return -1;		}			} else {		status_int = ret & 0xF8;	}	TPD_DEBUG("status_int = 0x%x\n", status_int);		ret = i2c_smbus_write_byte_data(ts->client, F11_2D_CTRL00, status_int);	if(ret < 0) {		TPD_DEBUG("synaptics_enable_interrupt_for_gusture: enable or disable\		    interrupt failed,abs_int =%d\n", status_int);		return -1;	}	TPD_DEBUG("synaptics_enable_interrupt_for gusture enable = %d\n", enable);	if(enable) {		abs_status_int = 0x3f;		/*clear interrupt bits for previous touch*/		ret = i2c_smbus_read_byte_data(ts->client, 0x14);		if(ret < 0) {			TPD_DEBUG("synaptics_enable_interrupt :clear interrupt bits failed\n");			return -1;		}	} else {		abs_status_int = 0x0;	}			ret = i2c_smbus_write_byte_data(ts->client, F01_RMI_CTRL01, abs_status_int);	if(ret < 0) {		TPD_DEBUG("synaptics_enable_interrupt: enable or disable abs \		    interrupt failed,abs_int =%d\n",abs_status_int);		return -1;	}		return 0;	}#endifstatic int synaptics_read_product_id(struct synaptics_ts_data *ts){	uint8_t buf1[11];	int ret ;	uint8_t q;		memset(buf1, 0 , sizeof(buf1));    /* page select = 0x0 */	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x0); 	if (ret < 0) {		TPDTM_DMESG("synaptics_read_product_id: failed for page select\n");		return -1;	}	ret = i2c_smbus_read_i2c_block_data(ts->client, F01_RMI_QUERY_BASE+11, 8, &(buf1[0x0]));	ret = i2c_smbus_read_i2c_block_data(ts->client, F01_RMI_QUERY_BASE+19, 2, &(buf1[0x8]));		if (ret < 0) {		TPDTM_DMESG("synaptics_read_product_id: failed to read product info\n");		return -1;	}	TPDTM_DMESG("synaptics product id: %s \n",buf1);	return 0;}static int synaptics_init_panel(struct synaptics_ts_data *ts){	int ret;	/* page select = 0x0 */	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x0); 	if (ret < 0) {		TPDTM_DMESG("i2c_smbus_write_byte_data failed for page select\n");		return -1;	}			/*device control: normal operation, configur=1*/	ret = i2c_smbus_write_byte_data(ts->client, F01_RMI_CTRL00, 0x80); 	if (ret < 0) {		TPDTM_DMESG("i2c_smbus_write_byte_data failed for mode select\n");		return -1;	}    /*enable absolutePosFilter,rezero*/	return ret;}static int synaptics_enable_interrupt(struct synaptics_ts_data *ts,    int enable){	int ret;	uint8_t abs_status_int;    /* page select = 0x0 */	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x0); 	if(ret < 0) {				TPDTM_DMESG("synaptics_enable_interrupt: select page failed ret = %d\n",		    ret);		return -1;	}    	if(enable) {		abs_status_int = 0x7f;		/*clear interrupt bits for previous touch*/		ret = i2c_smbus_read_byte_data(ts->client, F01_RMI_DATA_BASE+1);		if(ret < 0) {			TPDTM_DMESG("synaptics_enable_interrupt :clear interrupt bits failed\n");			return -1;		}	} else {		abs_status_int = 0x0;	}		ret = i2c_smbus_write_byte_data(ts->client, F01_RMI_CTRL00+1, abs_status_int);	if(ret < 0) {		TPDTM_DMESG("synaptics_enable_interrupt: enable or disable abs \		    interrupt failed,abs_int =%d\n",abs_status_int);		return -1;	}	ret = i2c_smbus_read_byte_data(ts->client, F01_RMI_CTRL00+1);	printk("S3202-----------0x5E=%x---------\n",ret);	return 0;	}static void synaptics_ts_irq_handler(void);static void delay_qt_ms(unsigned long  w_ms){    unsigned long i;    unsigned long j;    for (i = 0; i < w_ms; i++)    {        for (j = 0; j < 1000; j++)        {            udelay(1);        }    }}static void int_touch(struct synaptics_ts_data *ts){    int ret= -1,i=0, j = 0;    uint8_t buf[5];    uint32_t finger_state = 0;	uint8_t finger_num = 0;#ifdef SUPPORT_GUSTURE	int gusture_status;	int double_tap_status = 0;	int circle_status = 0;#endif    struct point_info points;    memset(buf,0,sizeof(buf));    ret = i2c_smbus_read_i2c_block_data(ts->client, F11_2D_DATA_BASE, 3, &(buf[0]));	if (ret < 0) {		TPDTM_DMESG("synaptics_ts_work_func: i2c_transfer failed\n");        return;	}    finger_state = ((buf[2]&0x0f)<<16)|(buf[1]<<8)|buf[0];		TPD_DEBUG("finger_state = 0x%x\n",finger_state);	for(j = 0;j < MAX_POINT_NUM;j++){	    if(finger_state&(0x03<<j*2))	    finger_num = finger_num+1;	}	TPD_DEBUG("finger_num = %d\n",finger_num);	if(finger_num > 0)	{			for(i = 0;i < MAX_POINT_NUM;i++)		{		    ret = i2c_smbus_read_i2c_block_data(ts->client, F11_2D_DATA_BASE + 3 + i*5,			        5, &(buf[0]));			if (ret < 0) {				TPDTM_DMESG("synaptics_ts_work_func: i2c_transfer failed\n");	        	return;			}			points.x = (buf[0]<<4) | (buf[2] & 0x0f);			points.raw_x = buf[3]&0x0f;			points.y = (buf[1]<<4) | ((buf[2] & 0xf0)>>4);			points.raw_y = (buf[3]&0xf0)>>4;		    points.z = buf[4];						if((boot_mode == FACTORY_BOOT)||(boot_mode == RECOVERY_BOOT))			tpd_button(ts,points.x,points.y,1);						if(points.z > 0){			tpd_down(ts,points.raw_x, points.raw_y, points.x, points.y,			    points.z);					}					}	}	else{		    if((boot_mode == FACTORY_BOOT)||(boot_mode == RECOVERY_BOOT))			tpd_button(ts,points.x,points.y,0);			tpd_up(ts,points.raw_x, points.raw_y, points.x, points.y,			    points.z);	}				input_sync(ts->input_dev);	ts->pre_finger_state = finger_state;  #ifdef SUPPORT_GUSTURE	if (finger_num == 0)	{        if(tp_dev == TP_TPK)		{			ret = i2c_smbus_read_word_data(ts->client, 0x4B);//0x4e			TPD_DEBUG("synaptics gusture awake working the reg 0x4B  = 0x%x\n\	        if bit0 = 1,double tap enable,if bit3 = 1 circle enable\n",ret);			gusture_status = ret&0x09;			if(gusture_status == 0x01)			{				double_tap_status = 1;			}			else if(gusture_status == 0x08)			{				circle_status = 1;			}			else			{				double_tap_status = 0;				circle_status = 0;			}		}		else		{		ret = i2c_smbus_read_word_data(ts->client, 0x4E);		TPD_DEBUG("the 0x4E is %x\n",ret);			if(ret&0x01)			{				double_tap_status = 1;			}			else			{				double_tap_status = 0;			}	//circle tuning				ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x04); 			if(ret < 0) 			{				TPD_DEBUG(" select page failed ret = %d\n",ret);			}			ret = i2c_smbus_read_word_data(ts->client, 0x00);			if(ret&0x02)			{				circle_status = 1;			}			else			{				circle_status = 0;			}			read_gusture = ret & 0xff;		}	//	TPD_DEBUG("the 0x00 for the circle tuning is %x\n",ret2);		if (double_tap_status||circle_status)		{			TPD_DEBUG("synaptics TP gesture power key pressed\n");			input_report_key(ts->input_dev, KEY_POWER, 1);			input_sync(ts->input_dev);				input_report_key(ts->input_dev, KEY_POWER, 0);			input_sync(ts->input_dev);			atomic_inc(&double_tap_number);			atomic_inc(&circle_gesture_number);		}				ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x00); 		if(ret < 0) 			TPD_DEBUG(" select page failed ret = %d\n",ret);	}#endif	}static void synaptics_ts_work_func(struct work_struct *work){	int ret;	uint8_t start_reg;	uint8_t buf[5]; 				/*17 edit by sun  for muiti Touchpanel */	uint8_t finger_num = 0;    uint32_t finger_state = 0;    uint8_t status = 0;	struct point_info points;	uint8_t inte = 0;	int i;	struct synaptics_ts_data *ts = container_of(work,	    struct synaptics_ts_data, work);	memset(buf,0,sizeof(buf));	if(is_suspend)	    return;       ret = i2c_smbus_read_byte_data(ts->client, F01_RMI_CTRL00+1);	//printk("S3202-----------0x5e=%x---------\n",ret);    ret  = i2c_smbus_read_byte_data(ts->client,F01_RMI_DATA_BASE+1);    // printk("0x14=======%x\n",ret);	ret = i2c_smbus_read_word_data(ts->client, F01_RMI_DATA_BASE);			if (ret < 0) {		TPDTM_DMESG("synaptics_ts_work_func: i2c_transfer failed\n");        goto ERR_I2C2;	}	status = ret&0xff;	inte = (ret&0x7f00)>>8;	TPDTM_DMESG("synaptics_ts_work_func,inte = %x, status = %x\n",inte,status);		if(status)	{		TPDTM_DMESG("synaptics_ts_work_func: tatus =%x\n",status);				ret = i2c_smbus_write_byte_data(ts->client, F01_RMI_CMD00,0x01);		if(ret) {			TPDTM_DMESG("synaptics_ts_work_func:cannot  reset touch panel \n");			goto ERR_I2C2;		}		//hwPowerOn(MT65XX_POWER_LDO_VIBR,VOL_2800,"CTP");		delay_qt_ms(150);		mt_set_gpio_dir(TOUCHPANEL_INT_PIN,GPIO_DIR_IN);		mt_set_gpio_pull_enable(TOUCHPANEL_INT_PIN, GPIO_PULL_ENABLE);		mt_set_gpio_pull_select(TOUCHPANEL_INT_PIN, GPIO_PULL_UP);		mt65xx_eint_set_polarity(CUST_EINT_TOUCH_PANEL_NUM,CUST_EINT_POLARITY_LOW);		mt65xx_eint_set_sens(CUST_EINT_TOUCH_PANEL_NUM,			CUST_EINT_LEVEL_SENSITIVE);//level low pull up		mt65xx_eint_set_hw_debounce(CUST_EINT_TOUCH_PANEL_NUM, 			(CUST_EINT_TOUCH_PANEL_DEBOUNCE_CN >> 4));		mt65xx_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, 					CUST_EINT_DEBOUNCE_DISABLE, 					CUST_EINT_POLARITY_LOW, 					synaptics_ts_irq_handler, 					0);		ret = synaptics_enable_interrupt(ts, 1);		if(ret) {			TPDTM_DMESG("synaptics_ts_work_func:cannot  enable interrupt \n");			goto ERR_I2C2 ;		}		synaptics_init_panel(ts);		if (ret < 0) {			TPDTM_DMESG("synaptics_ts_work_func: control tm1400 to sleep failed\n");			goto ERR_I2C2 ;		}		//hwPowerDown(MT65XX_POWER_LDO_VIBR,"CTP");		mt65xx_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);		return;	}	int_touch(ts);	ERR_I2C2:#ifdef TPD_USE_EINT	if (ts->use_irq)    	mt65xx_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);#endif}#ifndef TPD_USE_EINTstatic enum hrtimer_restart synaptics_ts_timer_func(struct hrtimer *timer){	struct synaptics_ts_data *ts = container_of(timer,	    struct synaptics_ts_data, timer);	/* TPDTM_DMESG("synaptics_ts_timer_func\n"); */	queue_work(synaptics_wq, &ts->work);	hrtimer_start(&ts->timer, ktime_set(0, 12500000), HRTIMER_MODE_REL);	return HRTIMER_NORESTART;}#elsestatic struct synaptics_ts_data *ts_g;static void synaptics_ts_irq_handler(void){	TPD_DEBUG("synaptics_ts_irq_handler\n");	mt65xx_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);	queue_work(synaptics_wq, &ts_g->work);}#endif#ifdef SUPPORT_GUSTUREstatic ssize_t tp_double_tap_num_show(struct device_driver *ddri, char *buf){    int ret = 0;		printk("double tap number is: %d\n", atomic_read(&double_tap_number));	ret = sprintf(buf, "%d\n", atomic_read(&double_tap_number));	return ret;}static ssize_t tp_double_tap_num_store(struct device_driver *ddri,       char *buf, size_t count){	int number;	if(1 == sscanf(buf, "%d", &number))	{		atomic_set(&double_tap_number, number);	}	else 	{		printk("invalid content: '%s', length = %d\n", buf, count);	} 		printk("tp_double_tap_num_store number=%d\n", atomic_read(&double_tap_number));		return count;}static ssize_t tp_double_tap_enable_show(struct device_driver *ddri, char *buf){    int ret = 0;	printk("double tap enable is: %d\n", atomic_read(&double_tap_enable));	ret = sprintf(buf, "%d\n", atomic_read(&double_tap_enable));		return ret;}static ssize_t tp_double_tap_enable_store(struct device_driver *ddri,       char *buf, size_t count){    int enable;    printk("wjw_tp_double_tap_num_store is called \n");	sscanf(buf, "%d", &enable);	atomic_set(&double_tap_enable, enable);	atomic_set(&circle_gesture_enable,enable);	printk("wjw_tp_double_tap_enable_store enable=%d\n", atomic_read(&double_tap_enable));	printk("wjw_tp_double_tap_enable_store enable=%d\n", atomic_read(&circle_gesture_enable));	return count;}#endif#ifdef SUPPORT_GUSTUREstatic DRIVER_ATTR(oppo_tp_double_tap_num, 0664, tp_double_tap_num_show, tp_double_tap_num_store);static DRIVER_ATTR(oppo_tp_double_tap_enable, 0777, tp_double_tap_enable_show, tp_double_tap_enable_store);#endifstatic ssize_t tp_show(struct device_driver *ddri, char *buf){    uint8_t ret = 0;	uint8_t d = 0;		/*mt65xx_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);	mt_set_gpio_mode(TOUCHPANEL_INT_PIN, GPIO_MODE_01);	mt_set_gpio_dir(TOUCHPANEL_INT_PIN,GPIO_DIR_IN);	mt_set_gpio_pull_enable(TOUCHPANEL_INT_PIN, GPIO_PULL_ENABLE);	mt_set_gpio_pull_select(TOUCHPANEL_INT_PIN, GPIO_PULL_UP);	mt65xx_eint_set_polarity(CUST_EINT_TOUCH_PANEL_NUM,CUST_EINT_POLARITY_LOW);	mt65xx_eint_set_sens(CUST_EINT_TOUCH_PANEL_NUM,		CUST_EINT_LEVEL_SENSITIVE);//level low pull up	mt65xx_eint_set_hw_debounce(CUST_EINT_TOUCH_PANEL_NUM, 			(CUST_EINT_TOUCH_PANEL_DEBOUNCE_CN >> 4));	mt65xx_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, 					CUST_EINT_DEBOUNCE_DISABLE, 					CUST_EINT_POLARITY_LOW, 					synaptics_ts_irq_handler, 					0);*/		mt65xx_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);	ret = i2c_smbus_read_word_data(ts_g, F01_RMI_DATA_BASE);	if(ret < 0)		printk("tp_show read i2c err\n");		//ret0 = i2c_smbus_read_byte_data(ts_g->client, 0x14);	//if(ret0 < 0)		//printk("tp_show read i2c err\n");	//update_lcd();	return sprintf(buf, "0x13=0x%x\n", ret);}static ssize_t store_tp(struct device_driver *ddri, char *buf, size_t count){	u8 tmp = 0;	if (1 == sscanf(buf, "%d", &tmp))	{		tp_debug = tmp;	}	else	{		TPDTM_DMESG("invalid content: '%s', length = %d\n", buf, count);	}		return count;}#define TX_NUM 14#define RX_NUM 26int DiagonalUpperLimit = 1100;int DiagonalLowerLimit = 900;static int16_t Truly_array_limit[] ={ 	1383,	2032,	1438,	2112,	1423,	2091,	1424,	2093,	1434,	2106,	1456,	2139,	1436,	2110,	1427,	2096,	1434,	2107,	1418,	2083,	1415,	2079,	1648,	2421,	1616,	2375,	1611,	2367,	1590,	2336,	1581,	2323,	1583,	2326,	1581,	2322,	1574,	2312,	1575,	2313,	1578,	2318,	1571,	2307,	1581,	2322,	1585,	2329,	1598,	2347,	1673,	2457,	1397,	2053,	1461,	2146,	1440,	2115,	1440,	2115,	1438,	2113,	1441,	2117,	1452,	2134,	1442,	2118,	1454,	2136,	1435,	2108,	1432,	2103,	1463,	2149,	1541,	2264,	1524,	2238,	1468,	2157,	1459,	2144,	1463,	2149,	1460,	2145,	1461,	2146,	1461,	2147,	1466,	2154,	1460,	2145,	1468,	2157,	1471,	2161,	1474,	2166,	1457,	2140,	1398,	2054,	1460,	2146,	1441,	2117,	1440,	2115,	1438,	2113,	1440,	2115,	1450,	2131,	1441,	2116,	1454,	2136,	1434,	2106,	1433,	2105,	1459,	2143,	1473,	2163,	1461,	2147,	1455,	2137,	1459,	2144,	1456,	2140,	1454,	2136,	1454,	2137,	1466,	2154,	1460,	2144,	1455,	2137,	1463,	2149,	1464,	2151,	1466,	2154,	1322,	1942,	1398,	2054,	1465,	2152,	1441,	2116,	1440,	2116,	1437,	2112,	1440,	2116,	1450,	2130,	1439,	2115,	1450,	2130,	1432,	2104,	1429,	2100,	1444,	2121,	1466,	2153,	1463,	2149,	1452,	2133,	1448,	2127,	1451,	2132,	1450,	2130,	1450,	2130,	1450,	2130,	1454,	2136,	1449,	2129,	1456,	2140,	1458,	2142,	1459,	2143,	1460,	2145,	1398,	2054,	1439,	2114,	1440,	2115,	1477,	2170,	1458,	2142,	1465,	2152,	1433,	2105,	1437,	2112,	1430,	2101,	1430,	2101,	1429,	2099,	1441,	2117,	1446,	2125,	1445,	2123,	1443,	2119,	1441,	2117,	1444,	2122,	1444,	2121,	1444,	2122,	1471,	2162,	1449,	2129,	1446,	2125,	1453,	2135,	1454,	2136,	1457,	2140,	1460,	2145,	1399,	2056,	1441,	2118,	1445,	2123,	1470,	2159,	1459,	2143,	1460,	2145,	1439,	2114,	1440,	2116,	1436,	2110,	1431,	2102,	1428,	2098,	1432,	2104,	1443,	2120,	1442,	2119,	1440,	2115,	1437,	2112,	1441,	2118,	1442,	2118,	1440,	2115,	1443,	2121,	1448,	2127,	1443,	2119,	1450,	2131,	1453,	2135,	1454,	2136,	1456,	2139,	1426,	2095,	1439,	2114,	1441,	2118,	1439,	2114,	1438,	2112,	1438,	2113,	1432,	2104,	1441,	2116,	1429,	2099,	1462,	2148,	1428,	2098,	1431,	2102,	1437,	2111,	1438,	2113,	1437,	2110,	1435,	2108,	1439,	2114,	1439,	2114,	1437,	2111,	1441,	2116,	1445,	2123,	1441,	2116,	1448,	2128,	1450,	2131,	1454,	2136,	1311,	1926,	1428,	2098,	1441,	2117,	1482,	2178,	1442,	2119,	1439,	2114,	1440,	2116,	1434,	2106,	1463,	2149,	1430,	2101,	1448,	2128,	1429,	2100,	1429,	2099,	1437,	2111,	1438,	2113,	1436,	2110,	1435,	2108,	1439,	2114,	1439,	2115,	1437,	2111,	1441,	2117,	1445,	2123,	1440,	2116,	1448,	2127,	1450,	2131,	1453,	2135,	1315,	1931,	1409,	2070,	1445,	2123,	1446,	2124,	1443,	2121,	1441,	2118,	1442,	2119,	1436,	2110,	1442,	2118,	1432,	2103,	1433,	2105,	1430,	2101,	1427,	2097,	1433,	2106,	1435,	2108,	1434,	2106,	1432,	2104,	1436,	2109,	1436,	2110,	1434,	2107,	1437,	2112,	1442,	2119,	1437,	2111,	1445,	2122,	1446,	2125,	1448,	2128,	1449,	2129,	1411,	2073,	1445,	2123,	1451,	2131,	1500,	2203,	1477,	2169,	1489,	2188,	1440,	2116,	1447,	2126,	1436,	2110,	1438,	2112,	1435,	2108,	1427,	2096,	1434,	2107,	1436,	2110,	1434,	2107,	1433,	2106,	1437,	2111,	1438,	2112,	1435,	2108,	1452,	2133,	1442,	2119,	1438,	2113,	1445,	2123,	1447,	2125,	1450,	2131,	1452,	2133,	1418,	2083,	1452,	2134,	1488,	2186,	1449,	2129,	1446,	2124,	1476,	2168,	1444,	2121,	1455,	2138,	1438,	2112,	1439,	2114,	1436,	2110,	1427,	2096,	1433,	2105,	1434,	2107,	1433,	2105,	1432,	2104,	1435,	2108,	1436,	2109,	1434,	2107,	1439,	2114,	1441,	2118,	1437,	2111,	1443,	2120,	1444,	2122,	1447,	2126,	1443,	2120,	1433,	2105,	1446,	2124,	1452,	2133,	1447,	2125,	1446,	2125,	1447,	2127,	1442,	2118,	1453,	2134,	1440,	2115,	1484,	2180,	1438,	2112,	1426,	2094,	1433,	2105,	1434,	2107,	1432,	2104,	1432,	2103,	1435,	2108,	1436,	2109,	1433,	2105,	1437,	2110,	1440,	2116,	1436,	2110,	1442,	2118,	1444,	2121,	1445,	2122,	1283,	1886,	1435,	2108,	1473,	2165,	1474,	2165,	1505,	2212,	1494,	2196,	1522,	2237,	1449,	2129,	1464,	2151,	1445,	2122,	1450,	2130,	1442,	2119,	1425,	2094,	1432,	2103,	1433,	2106,	1431,	2103,	1430,	2101,	1434,	2107,	1434,	2107,	1432,	2104,	1435,	2109,	1440,	2115,	1434,	2107,	1441,	2117,	1442,	2118,	1443,	2121,	1414,	2078,	1527,	2244,	1534,	2253,	1551,	2278,	1544,	2268,	1549,	2276,	1551,	2279,	1545,	2269,	1557,	2287,	1544,	2269,	1564,	2297,	1549,	2276,	1385,	2035,	1392,	2045,	1394,	2048,	1392,	2045,	1392,	2044,	1394,	2047,	1395,	2050,	1392,	2045,	1396,	2051,	1399,	2055,	1394,	2048,	1400,	2057,	1402,	2059,	1401,	2059,	1407,	2067};static int16_t TPK_array_limit[] = {	1604,	2673,	1649,	2749,	1600,	2667,	1577,	2629,	1584,	2640,	1575,	2625,	1586,	2643,	1586,	2643,	1581,	2636,	1581,	2635,	1586,	2643,	1578,	2630,	1586,	2644,	1590,	2650,	1626,	2710,	1407,	2345,	1423,	2372,	1405,	2342,	1432,	2386,	1395,	2324,	1438,	2397,	1434,	2389,	1439,	2399,	1401,	2335,	1433,	2388,	1394,	2323,	1577,	2629,	1603,	2672,	1568,	2614,	1562,	2604,	1551,	2585,	1547,	2578,	1547,	2578,	1548,	2579,	1544,	2573,	1545,	2574,	1540,	2567,	1538,	2563,	1536,	2560,	1537,	2562,	1549,	2582,	1478,	2463,	1487,	2478,	1500,	2501,	1496,	2493,	1465,	2442,	1486,	2477,	1473,	2455,	1487,	2478,	1464,	2440,	1487,	2478,	1462,	2437,	1540,	2566,	1579,	2631,	1560,	2601,	1547,	2578,	1547,	2578,	1542,	2570,	1543,	2572,	1545,	2575,	1540,	2566,	1539,	2564,	1536,	2559,	1530,	2550,	1531,	2552,	1529,	2548,	1536,	2559,	1477,	2462,	1491,	2485,	1476,	2460,	1501,	2502,	1467,	2445,	1510,	2517,	1481,	2468,	1516,	2526,	1470,	2450,	1512,	2520,	1466,	2444,	1527,	2545,	1565,	2609,	1551,	2585,	1546,	2577,	1539,	2565,	1533,	2556,	1533,	2555,	1532,	2553,	1529,	2549,	1530,	2551,	1524,	2541,	1521,	2535,	1517,	2529,	1516,	2527,	1514,	2523,	1477,	2462,	1485,	2475,	1484,	2473,	1493,	2489,	1463,	2438,	1484,	2473,	1471,	2452,	1484,	2474,	1462,	2438,	1486,	2477,	1463,	2438,	1521,	2535,	1552,	2587,	1548,	2580,	1538,	2563,	1538,	2563,	1532,	2554,	1531,	2552,	1527,	2545,	1527,	2545,	1526,	2544,	1523,	2538,	1517,	2529,	1518,	2530,	1514,	2524,	1512,	2520,	1483,	2471,	1495,	2491,	1479,	2465,	1504,	2506,	1477,	2461,	1506,	2509,	1499,	2498,	1499,	2499,	1490,	2483,	1508,	2513,	1499,	2498,	1506,	2511,	1546,	2577,	1537,	2562,	1533,	2555,	1528,	2547,	1524,	2540,	1524,	2540,	1522,	2537,	1519,	2532,	1521,	2534,	1514,	2523,	1512,	2520,	1511,	2518,	1509,	2515,	1503,	2504,	1485,	2475,	1493,	2489,	1481,	2468,	1503,	2504,	1474,	2456,	1494,	2490,	1481,	2469,	1494,	2490,	1473,	2455,	1496,	2494,	1477,	2461,	1504,	2507,	1539,	2566,	1537,	2561,	1528,	2546,	1529,	2548,	1520,	2533,	1524,	2540,	1520,	2533,	1520,	2533,	1519,	2531,	1516,	2526,	1510,	2517,	1511,	2518,	1508,	2514,	1502,	2503,	1513,	2522,	1505,	2509,	1508,	2514,	1512,	2520,	1517,	2528,	1502,	2504,	1488,	2480,	1503,	2506,	1481,	2468,	1506,	2509,	1484,	2473,	1496,	2494,	1537,	2561,	1531,	2552,	1525,	2542,	1522,	2536,	1517,	2528,	1518,	2530,	1516,	2526,	1514,	2523,	1513,	2522,	1509,	2515,	1507,	2512,	1503,	2506,	1503,	2505,	1495,	2492,	1500,	2501,	1503,	2505,	1491,	2485,	1509,	2515,	1480,	2467,	1500,	2500,	1489,	2481,	1502,	2503,	1481,	2468,	1505,	2508,	1486,	2477,	1501,	2501,	1533,	2556,	1534,	2556,	1525,	2542,	1526,	2543,	1563,	2605,	1520,	2534,	1517,	2528,	1518,	2531,	1516,	2526,	1512,	2519,	1508,	2514,	1507,	2512,	1508,	2513,	1496,	2494,	1516,	2526,	1523,	2539,	1502,	2503,	1525,	2542,	1492,	2487,	1517,	2529,	1524,	2539,	1515,	2524,	1513,	2521,	1521,	2535,	1534,	2557,	1495,	2492,	1535,	2558,	1531,	2552,	1525,	2542,	1522,	2536,	1515,	2525,	1518,	2530,	1515,	2525,	1512,	2520,	1514,	2523,	1507,	2511,	1506,	2511,	1503,	2505,	1501,	2502,	1491,	2486,	1529,	2548,	1516,	2527,	1506,	2511,	1523,	2538,	1512,	2520,	1514,	2523,	1557,	2594,	1518,	2530,	1534,	2556,	1523,	2538,	1560,	2600,	1497,	2495,	1532,	2553,	1530,	2551,	1522,	2536,	1522,	2536,	1516,	2527,	1517,	2529,	1513,	2522,	1511,	2519,	1513,	2521,	1508,	2513,	1506,	2510,	1504,	2507,	1501,	2502,	1492,	2486,	1536,	2560,	1543,	2572,	1516,	2527,	1538,	2564,	1511,	2519,	1526,	2543,	1535,	2558,	1527,	2546,	1531,	2552,	1531,	2552,	1573,	2622,	1487,	2478,	1528,	2546,	1526,	2544,	1519,	2532,	1517,	2528,	1511,	2519,	1514,	2524,	1511,	2518,	1508,	2514,	1510,	2516,	1505,	2508,	1503,	2505,	1500,	2500,	1499,	2499,	1488,	2480,	1550,	2584,	1530,	2550,	1525,	2542,	1533,	2555,	1512,	2520,	1524,	2540,	1517,	2528,	1527,	2545,	1510,	2517,	1533,	2555,	1535,	2558,	1488,	2480,	1527,	2545,	1528,	2546,	1520,	2533,	1520,	2534,	1520,	2534,	1518,	2530,	1513,	2522,	1513,	2521,	1513,	2522,	1509,	2515,	1506,	2510,	1505,	2509,	1503,	2506,	1493,	2488,	1612,	2686,	1615,	2692,	1548,	2580,	1567,	2612,	1566,	2611,	1565,	2608,	1551,	2584,	1551,	2585,	1531,	2551,	1559,	2598,	1574,	2623,	1459,	2432,	1496,	2494,	1494,	2490,	1488,	2480,	1487,	2479,	1481,	2469,	1485,	2475,	1482,	2470,	1480,	2466,	1482,	2469,	1474,	2457,	1473,	2456,	1471,	2452,	1470,	2450,	1460,	2433,	1688,	2814,	1626,	2710,	1617,	2695,	1628,	2714,	1607,	2679,	1620,	2699,	1619,	2698,	1632,	2720,	1624,	2707,	1661,	2769,	1762,	2936};static void checkCMD(){  int ret; do {        delay_qt_ms(10); //wait 1ms        ret =  i2c_smbus_read_byte_data(ts_g->client,F54_ANALOG_COMMAND_BASE);            } while (ret > 0x00); }static void synaptics_read_register_map_page1(struct synaptics_ts_data *ts){unsigned char buf[4];int ret;printk("synaptics_read_register_map_page1 start\n");ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x1); if (ret < 0) {		TPDTM_DMESG("i2c_smbus_write_byte_data failed for page select\n");		return -1;	}ret = i2c_smbus_read_i2c_block_data(ts->client, 0xE9, 4, &(buf[0x0]));F54_ANALOG_QUERY_BASE = buf[0];printk("F54_ANALOG_QUERY_BASE = 0x%x\n",F54_ANALOG_QUERY_BASE);F54_ANALOG_COMMAND_BASE = buf[1];printk("F54_ANALOG_COMMAND_BASE = 0x%x\n",F54_ANALOG_COMMAND_BASE);F54_ANALOG_CONTROL_BASE = buf[2];printk("F54_ANALOG_CONTROL_BASE = 0x%x\n",F54_ANALOG_CONTROL_BASE);F54_ANALOG_DATA_BASE = buf[3];printk("F54_ANALOG_DATA_BASE = 0x%x\n",F54_ANALOG_DATA_BASE);}static ssize_t tp_delta_show(struct device_driver *ddri, char *buf){    int ret = 0;	int x,y;	ssize_t num_read_chars = 0;	uint8_t tmp = 0;	uint8_t tmp_old = 0,tmp_new = 0;	uint8_t tmp_l = 0,tmp_h = 0; 	uint16_t count = 0;	int16_t delta_image[TX_NUM][RX_NUM] = {0};		int16_t baseline_data[TX_NUM][RX_NUM] = {0};    mt65xx_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);	synaptics_read_register_map_page1(ts_g);		printk("\nstep 1:select report type 0x03 baseline\n");	 //step 1:check raw capacitance.	ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_DATA_BASE,0x03);//select report type 0x03	 if (ret < 0) {		 TPDTM_DMESG("read_baseline: i2c_smbus_write_byte_data failed \n");		 //return sprintf(buf, "i2c err!");	}	ret = i2c_smbus_write_word_data(ts_g->client,F54_ANALOG_DATA_BASE+1,0x00);//set fifo 00    ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_COMMAND_BASE,0X01);//get report	checkCMD();	count = 0;	for(x = 0;x < TX_NUM; x++)   	{   		  printk("\n[%d]",x);      for(y = 0; y < RX_NUM; y++)   	  {	    ret = i2c_smbus_read_byte_data(ts_g->client,F54_ANALOG_DATA_BASE+3);	    tmp_l = ret&0xff;	    ret = i2c_smbus_read_byte_data(ts_g->client,F54_ANALOG_DATA_BASE+3);	    tmp_h = ret&0xff;	    baseline_data[x][y] = (tmp_h<<8)|tmp_l;	    printk("%d,",baseline_data[x][y]);		  }   	}	printk("\nstep 2:report type2 delta image\n");		ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_DATA_BASE,0x02);//select report type 0x02	ret = i2c_smbus_write_word_data(ts_g->client,F54_ANALOG_DATA_BASE+1,0x00);//set fifo 00    ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_COMMAND_BASE,0X01);//get report	checkCMD();	count = 0;	for(x = 0;x < TX_NUM; x++)	{		printk("\n[%d]",x);		 for(y = 0; y < RX_NUM; y++)		 {			ret = i2c_smbus_read_byte_data(ts_g->client,F54_ANALOG_DATA_BASE+3);			tmp_l = ret&0xff;			ret = i2c_smbus_read_byte_data(ts_g->client,F54_ANALOG_DATA_BASE+3);			tmp_h = ret&0xff;			delta_image[x][y]= (tmp_h<<8)|tmp_l;       					printk("%3d,",delta_image[x][y]);		 }	 	}	END:    ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_COMMAND_BASE,0X02);    delay_qt_ms(60);    synaptics_enable_interrupt(ts_g,1);	mt65xx_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);}static ssize_t tp_delta_store(struct device_driver *ddri,       char *buf, size_t count){	  printk("tp_test_store is not support\n");	  return count;}static ssize_t tp_test_show(struct device_driver *ddri, char *buf){    int ret = 0;	int x,y;	int tx_data = 0;	int tx_datah;	int tx_datal;	int16_t baseline_data = 0;	uint8_t tmp = 0;	uint8_t tmp_old = 0,tmp_new = 0;	uint8_t tmp_l = 0,tmp_h = 0; 	ssize_t num_read_chars = 0;	int16_t Rxdata[RX_NUM][RX_NUM] = {0};	uint16_t count = 0;    down(&work_sem);    get_tp_id();    mt65xx_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);		synaptics_read_register_map_page1(ts_g);/*		tp_dev = TP_TRULY;	if(ret){		tp_dev = TP_TRULY;		TPDTM_DMESG("this is Truly TP, GPIO84 = %d\n",ret);	}	else{				tp_dev = TP_YOUNGFAST;		TPDTM_DMESG("this is YongFast TP,GPIO84 = %d\n",ret);	}*/		printk("step 1:select report type 0x03\n");	 //step 1:check raw capacitance.	ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_DATA_BASE,0x03);//select report type 0x03	 if (ret < 0) {		 TPD_DEBUG("read_baseline: i2c_smbus_write_byte_data failed \n");		 //return sprintf(buf, "i2c err!");	}	 	ret = i2c_smbus_read_byte_data(ts_g->client,F54_ANALOG_CONTROL_BASE+8);	tmp_old = ret&0xff;	tmp_new = tmp_old & 0xef;	printk("ret = %x ,tmp_old =%x ,tmp_new = %x\n",ret,tmp_old,tmp_new);	ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_CONTROL_BASE+8,tmp_new);	ret = i2c_smbus_write_word_data(ts_g->client,F54_ANALOG_COMMAND_BASE,0x04);	checkCMD();	printk("forbid CBC oK\n");	ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_CONTROL_BASE + 81,0X01);  //Forbid NoiseMitigation F54_ANALOG_CTRL41    ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_COMMAND_BASE,0X04);//force F54_ANALOG_CMD00    checkCMD();	printk("forbid Forbid NoiseMitigation oK\n");	ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_COMMAND_BASE,0X02);//Force Cal, F54_ANALOG_CMD00    checkCMD();	printk("Force Cal oK\n");	ret = i2c_smbus_write_word_data(ts_g->client,F54_ANALOG_DATA_BASE+1,0x00);//set fifo 00    ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_COMMAND_BASE,0X01);//get report	checkCMD();	count = 0;	for(x = 0;x < TX_NUM; x++)   	{      for(y = 0; y < RX_NUM; y++)   	  {	    ret = i2c_smbus_read_byte_data(ts_g->client,F54_ANALOG_DATA_BASE+3);	    tmp_l = ret&0xff;	    ret = i2c_smbus_read_byte_data(ts_g->client,F54_ANALOG_DATA_BASE+3);	    tmp_h = ret&0xff;	    baseline_data = (tmp_h<<8)|tmp_l;	    printk("%d,",baseline_data);    #if 1	if(tp_dev  == TP_TRULY)		{			   if((baseline_data < Truly_array_limit[count*2]) || (baseline_data > Truly_array_limit[count*2+1])){			   printk("===>wjw_tpbaseline_fail;count[%d][%d] =%d ;Truly_array_limit[count*2]=%d,Truly_array_limit[count*2+1]=%d\n ",count*2,(count*2+1),baseline_data,Truly_array_limit[count*2],Truly_array_limit[count*2+1]);			        num_read_chars += sprintf(&(buf[num_read_chars]), "0 raw data erro baseline_data[%d][%d]=%d[%d,%d]\n",x,y,baseline_data,Truly_array_limit[count*2],Truly_array_limit[count*2+1]);					goto END;			   }	      }	 else	 	{			  if((baseline_data < TPK_array_limit[count*2]) || (baseline_data > TPK_array_limit[count*2+1])){			  printk("===>wjw_tpbaseline_fail;count[%d][%d] =%d ;Truly_array_limit[count*2]=%d,Truly_array_limit[count*2+1]=%d\n ",count*2,(count*2+1),baseline_data,TPK_array_limit[count*2],TPK_array_limit[count*2+1]);			        num_read_chars += sprintf(&(buf[num_read_chars]), "0 raw data erro baseline_data[%d][%d]=%d[%d,%d]\n",x,y,baseline_data,TPK_array_limit[count*2],TPK_array_limit[count*2+1]);					goto END;			   }	 }		  #endif	    count++;	  }	  printk("\n");   	}		ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_CONTROL_BASE+8,tmp_old);	ret = i2c_smbus_write_word_data(ts_g->client,F54_ANALOG_COMMAND_BASE,0x04);	checkCMD();	ret = i2c_smbus_read_byte_data(ts_g->client,F54_ANALOG_CONTROL_BASE+8);	printk("[s3202]tem_new end = %x",ret&0xff);		printk("step 2:check tx-to-tx and tx-to-vdd\n" );    //step 2 :check tx-to-tx and tx-to-vdd    ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_DATA_BASE,0x05);//select report type 0x05	     ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_COMMAND_BASE,0X01);//get report    checkCMD();    ret = i2c_smbus_write_word_data(ts_g->client,F54_ANALOG_DATA_BASE+1,0);	    tx_datal = i2c_smbus_read_word_data(ts_g->client,F54_ANALOG_DATA_BASE+3);    tx_datah = i2c_smbus_read_word_data(ts_g->client,F54_ANALOG_DATA_BASE+3);	tx_data = tx_datal | tx_datah<<16;     if( tx_data!= 0)	{		printk("Step 2 error.\n");	   num_read_chars += sprintf(buf, "0 tx-tx-short or tx-vdd-short");	   goto END;	}  printk("step 3 :check rx-to-rx\n" ); //step 3 :check rx-to-rx    ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_DATA_BASE,7);//select report type 0x07    ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_CONTROL_BASE + 81,0X01); //forbid NoisMitigation 	  //Forbid NoiseMitigation F54_ANALOG_CTRL41    ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_COMMAND_BASE,0X04);//force F54_ANALOG_CMD00    checkCMD();                               //    ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_COMMAND_BASE,0X02);//Force Cal,F54_ANALOG_CMD00    checkCMD();    ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_COMMAND_BASE,0X01);//get report    checkCMD();    ret = i2c_smbus_read_byte_data(ts_g->client,F54_ANALOG_COMMAND_BASE);//read report	printk("F54_ANALOG_CMD00[2]=%d \n",ret);	ret = i2c_smbus_write_word_data(ts_g->client,F54_ANALOG_DATA_BASE+1,0);	for(x = 0;x < TX_NUM; x++)   	{      for(y = 0; y < RX_NUM; y++)   	    {	   	         ret= i2c_smbus_read_word_data(ts_g->client,F54_ANALOG_DATA_BASE+3);			 Rxdata[x][y] = ret&0xffff;		        		}	}    ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_DATA_BASE,17);//select report type 0x17     ret = i2c_smbus_write_word_data(ts_g->client,F54_ANALOG_DATA_BASE+1,0);    ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_COMMAND_BASE,0X01);//get report    checkCMD();	for(x = 0;x < RX_NUM - TX_NUM; x++)   	{      for(y = 0; y < RX_NUM; y++)   	    {	   	         ret= i2c_smbus_read_word_data(ts_g->client,F54_ANALOG_DATA_BASE+3);			 Rxdata[x + TX_NUM][y] = ret&0xffff;	 		    // printk("\nRxdata[%d][%d] = %d",x+TX_NUM,y,Rxdata[x + TX_NUM][y]);   		}	}	printk("\nstep 4:check rx-rx short\n");//step 4:check rx-rx short	if (tp_dev = TP_TRULY){		for(x = 0;x < RX_NUM; x++)   	{	      for(y = 0; y < RX_NUM; y++)   	  {			  if (x ==y)			{								 printk("check Rx-to-Rx and Rx-to-vdd_error,Rxdata[%d]=%d \n",x,Rxdata[x][y]);	                if((Rxdata[x][y] < DiagonalLowerLimit)|| (Rxdata[x][y] >DiagonalUpperLimit))	                   {	                     num_read_chars += sprintf(buf, "0 rx-to-rx short or rx-to-vdd short Rxdata[%d][%d] = %d",x,y,Rxdata[x][y]);						 printk("wjw_check Rx-to-Rx and Rx-to-vdd_error,Rxdata[%d]=%d \n",x,Rxdata[x][y]);						 goto END;					   }				 }		   }		 }	}	else{	for(x = 0;x < RX_NUM; x++)   	{      for(y = 0; y < RX_NUM; y++)   	  {	    if ((x ==y)&&(x!=19))		{							 printk("check Rx-to-Rx and Rx-to-vdd_error,Rxdata[%d]=%d \n",x,Rxdata[x][y]);                              if((Rxdata[x][y] < DiagonalLowerLimit)|| (Rxdata[x][y] >DiagonalUpperLimit))                   {                     num_read_chars += sprintf(buf, "0 rx-to-rx short or rx-to-vdd short Rxdata[%d][%d] = %d",x,y,Rxdata[x][y]);					 printk("wjw_check Rx-to-Rx and Rx-to-vdd_error,Rxdata[%d]=%d \n",x,Rxdata[x][y]);					 goto END;				   }							 }	   }	 }	}	num_read_chars += sprintf(buf, "1");END:    ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_CONTROL_BASE+8,tmp_old);	ret = i2c_smbus_write_word_data(ts_g->client,F54_ANALOG_COMMAND_BASE,0x04);	checkCMD();	ret = i2c_smbus_read_byte_data(ts_g->client,F54_ANALOG_CONTROL_BASE+8);	printk("[s3202]tem_new end = %x",ret&0xff);	printk("4 read F54_ANALOG_CTRL07 is: 0x%x\n",ret);    ret = i2c_smbus_write_byte_data(ts_g->client,F54_ANALOG_COMMAND_BASE,0X02);    delay_qt_ms(60);    ret = i2c_smbus_write_byte_data(ts_g->client, 0xff, 0x00);    ret = i2c_smbus_write_byte_data(ts_g->client, F01_RMI_CMD00,0x01);    msleep(150);    synaptics_init_panel(ts_g);    synaptics_enable_interrupt(ts_g,1);	mt65xx_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);		printk("\n\nstep5 reset and open irq complete\n");    up(&work_sem);	return num_read_chars;	}static ssize_t tp_test_store(struct device_driver *ddri,       char *buf, size_t count){   printk("tp_test_store is not support\n");   return count;}static DRIVER_ATTR(oppo_tp_delta_image, 0664, tp_delta_show, tp_delta_store);static DRIVER_ATTR(oppo_tp_test, 0664, tp_test_show, tp_test_store);static DRIVER_ATTR(oppo_tp_debug, 0664, tp_show, store_tp);static int tp_write_func (struct file *file,const char *buffer,    unsigned long count,void *data);#ifdef SUPPORT_GUSTUREstatic int tp_double_write_func (struct file *file,const char *buffer,    unsigned long count,void *data);static int tp_double_read_func (char *page,const char **stat,    off_t off,int count,int *eof,void *data);#endifstatic int init_synaptics_proc(){	int ret = 0;	prEntry = create_proc_entry( "synaptics_reset_3202", 0666, NULL );	if(prEntry == NULL)	{		ret = -ENOMEM;	  	printk(KERN_INFO"init_synaptics_proc: Couldn't create proc entry\n");	}	else{		prEntry->write_proc = tp_write_func;	}#ifdef SUPPORT_GUSTURE		printk("init_synaptics_proc : SUPPORT_GUSTURE start ......\n");		prEntry_double = create_proc_entry( "driver_attr_oppo_tp_double_tap_enable", 0777, NULL );		if(prEntry == NULL)		{			ret = -ENOMEM;			printk(KERN_INFO"init_synaptics_proc: Couldn't create proc entry\n");		}		else{			printk("init_synaptics_proc : SUPPORT_GUSTURE start ......\n");			prEntry_double->write_proc = tp_double_write_func;			prEntry_double->read_proc = tp_double_read_func;		}#endif		return ret;}static int tp_write_func (struct file *file,const char *buffer,    unsigned long count,void *data){	struct synaptics_ts_data *ts; 	int ret = 0;	uint8_t d;	if(ts_g){		ts = ts_g;		if(is_suspend)		    return count;	ret = i2c_smbus_write_byte_data(ts->client, F01_RMI_CMD00, 0x01);	ret = i2c_smbus_write_byte_data(ts->client,F01_RMI_CMD00+1, 0x01);		if(ret)		{			TPDTM_DMESG("tp_write_func: rezero error!\n");			return count;		}				TPDTM_DMESG("tp_write_func: rezero/reset successed!\n");	}	return count;}#ifdef SUPPORT_GUSTURE static int tp_double_write_func (struct file *file,const char *buffer,	 unsigned long count,void *data)	 {		 int ret = 0;		 sscanf(buffer,"%d",&ret);		 TPDTM_DMESG("tp_double_write_func:buffer = %d,ret = %d\n",*buffer,ret);		 if((ret == 0 )||(ret == 1))		 {			atomic_set(&double_tap_enable,ret);			atomic_set(&circle_gesture_enable,ret);			atomic_set(&gusture_enable,ret);				}		 switch(ret)		 {	 case 0:				 TPDTM_DMESG("tp_guesture_func will be disable\n");				 break;			 case 1:				 TPDTM_DMESG("tp_guesture_func will be enable\n");				 break;			 default:TPDTM_DMESG("Please enter 0 or 1 to open or close the double-tap function\n");		 }		 return count;	 }	  static int tp_double_read_func (char *page,const char **stat,	 off_t off,int count,int *eof,void *data)	 {		 TPDTM_DMESG("tp_double_read_func is called\n ");		  int ret;		  ret =atomic_read(&double_tap_enable); 		 if (ret == 0)			 TPDTM_DMESG("double-tap function is disable\n");		 if (ret == 1)			 TPDTM_DMESG("double-tap function is enable\n");		 return 0;	 }#endif static void re_scan_PDT(struct i2c_client *client)  {	  uint8_t buf[8];	  i2c_smbus_read_i2c_block_data(client, 0xE9, 6,  buf);	  SynaF34DataBase = buf[3];	  SynaF34QueryBase = buf[0];	  i2c_smbus_read_i2c_block_data(client, 0xE3, 6,  buf);	  SynaF01DataBase = buf[3];	  SynaF01CommandBase = buf[1];	  i2c_smbus_read_i2c_block_data(client, 0xDD, 6,  buf);	  SynaF34Reflash_BlockNum = SynaF34DataBase;	  SynaF34Reflash_BlockData = SynaF34DataBase + 2;	  SynaF34ReflashQuery_BootID = SynaF34QueryBase;	  SynaF34ReflashQuery_FlashPropertyQuery = SynaF34QueryBase + 2;	  SynaF34ReflashQuery_FirmwareBlockSize = SynaF34QueryBase + 3;	  SynaF34ReflashQuery_FirmwareBlockCount = SynaF34QueryBase +5;	  SynaF34ReflashQuery_ConfigBlockSize = SynaF34QueryBase + 3;	  SynaF34ReflashQuery_ConfigBlockCount = SynaF34QueryBase + 7;	  i2c_smbus_read_i2c_block_data(client, SynaF34ReflashQuery_FirmwareBlockSize,		  2, buf);	  SynaFirmwareBlockSize = buf[0] | (buf[1] << 8);	  SynaF34_FlashControl = SynaF34DataBase + SynaFirmwareBlockSize + 2;  } static enum wk_wdt_type {	 WK_WDT_LOC_TYPE,	 WK_WDT_EXT_TYPE }; extern void mtk_wdt_restart(enum wk_wdt_type type); static int kick_wdt() {	 mtk_wdt_restart(WK_WDT_LOC_TYPE);	 mtk_wdt_restart(WK_WDT_EXT_TYPE); } static int synatpitcs_ts_update(struct i2c_client *client){    uint8_t data_low8,data_high8;    uint16_t block,firmware,configuration;	unsigned char uData;	unsigned char uStatus;    uint8_t buf[8];    int ret,i,j;    i2c_smbus_write_byte_data(client, 0xff, 0x0);		re_scan_PDT(client);    block = 16;    printk("block is %d \n",block);    firmware = 2816;    printk("firmware is %d \n",firmware);    configuration = 32;    printk("configuration is %d \n",configuration);    data_low8 = i2c_smbus_read_byte_data(client, SynaF34ReflashQuery_BootID);    data_high8 = i2c_smbus_read_byte_data(client,SynaF34ReflashQuery_BootID+1);    printk("bootloader id is %x \n",(data_high8 << 8)|data_low8);    i2c_smbus_write_byte_data(client,SynaF34Reflash_BlockData,data_low8);    i2c_smbus_write_byte_data(client,SynaF34Reflash_BlockData+1,data_high8);    printk("Write bootloader id\n");    i2c_smbus_write_byte_data(client,SynaF34_FlashControl,0x0F);    msleep(10);    printk("attn step 4\n");    ret = i2c_smbus_read_byte_data(client,SynaF34_FlashControl);    printk("The status(enter flash) is %x\n",ret);	re_scan_PDT(client);    i2c_smbus_read_i2c_block_data(client,SynaF34ReflashQuery_BootID,2,buf);    i2c_smbus_write_i2c_block_data(client,SynaF34Reflash_BlockData,2,buf);    i2c_smbus_write_byte_data(client,SynaF34_FlashControl,0x03);    msleep(200);	kick_wdt();    ret = i2c_smbus_read_byte_data(client,SynaF34_FlashControl);    printk("The status(erase) is %x\n",ret);    for(j=0;j<firmware;j++)    {        buf[0]=j&0x00ff;        buf[1]=(j&0xff00)>>8;        i2c_smbus_write_i2c_block_data(client,SynaF34Reflash_BlockNum,2,buf);               for(i=0;i<block;i++)	               {			                     if(tp_dev == TP_TRULY)			                      i2c_smbus_write_byte_data(client,SynaF34Reflash_BlockData+i,			       TRULY_Firmware_Data[j][i]); 				                     if(tp_dev == TP_TPK)			                      i2c_smbus_write_byte_data(client,SynaF34Reflash_BlockData+i,			       TPK_Firmware_Data[j][i]); 			   }        i2c_smbus_write_byte_data(client,SynaF34_FlashControl,0x02);        msleep(5);        ret = i2c_smbus_read_byte_data(client,SynaF34_FlashControl);        printk("The status(Image) of flash data3 is %x,time =%d\n",            ret,j);	   if(j % 500 == 0){		   kick_wdt();	   	}    }		kick_wdt();    //step 7 configure data    for(j=0;j<configuration;j++)    {        //a)        buf[0]=j&0x00ff;        buf[1]=(j&0xff00)>>8;        i2c_smbus_write_i2c_block_data(client,SynaF34Reflash_BlockNum,2,buf);        //b) write data		   			    for(i=0;i<block;i++)                {				    if(tp_dev == TP_TRULY)			       i2c_smbus_write_byte_data(client,SynaF34Reflash_BlockData+i,                   TRULY_Config_Data[j][i]);				    				    if(tp_dev == TP_TPK)			       i2c_smbus_write_byte_data(client,SynaF34Reflash_BlockData+i,                   TPK_Config_Data[j][i]);									                   }				   			        //c) issue write        i2c_smbus_write_byte_data(client,SynaF34_FlashControl,0x06);        //d) wait attn        //delay_qt_ms(20);        msleep(5);        ret = i2c_smbus_read_byte_data(client,SynaF34_FlashControl);        printk("The status(Image) of flash data3 is %x,time =%d\n",            ret,j);			    }	kick_wdt();    //disable    //step 1 issue reset    i2c_smbus_write_byte_data(client,SynaF01CommandBase,0X01);    //step2 wait ATTN    //delay_qt_ms(1000);    msleep(200);    //step 3 check status    ret = i2c_smbus_read_byte_data(client,SynaF34_FlashControl);    printk("The status(disable)of flash data3 is %0x\n",ret); }static int get_tp_id(){	int ID1,ID2;	 	mt_set_gpio_mode(149, 0);     mt_set_gpio_dir(149,0);// 0);    mt_set_gpio_pull_select(149,1);    mt_set_gpio_pull_enable(149,1);   // mt_set_gpio_out(GPIOEXT17,1);	printk("has all____________________________________-----------------gpio249 = %d\n", mt_get_gpio_in(GPIOEXT17));		    mt_set_gpio_mode(138, 0);     mt_set_gpio_dir(138, 0);    mt_set_gpio_pull_select(138,1);    mt_set_gpio_pull_enable(138,1);		 	ID1 = mt_get_gpio_in(149);	ID2 = mt_get_gpio_in(138);	printk("ID1 is %d     ID2 is wo %d \n",ID1,ID2);	if(!(ID1 || ID2 ))	{		tp_dev = TP_TPK;		printk("TP is TP_TPK\n");	}	if(ID1 && ID2)	{		tp_dev = TP_TRULY;		printk("TP is TP_TRULY\n");	}	return 0;}static int synaptics_ts_probe(	struct i2c_client *client, const struct i2c_device_id *id){	struct synaptics_ts_data *ts;	int ret = 0;	uint8_t buf[4];	uint32_t CURRENT_FIRMWARE_ID = 0;	uint32_t bootloader_mode;    uint32_t FIRMWARE_ID_TRULY = 0;	uint32_t FIRMWARE_ID_TPK  =0;	uint8_t fw_cnt = 0;		TPDTM_DMESG("synaptics_ts_probe: enter !!!!!!!!!!!!!!\n");		tpd_power(1);		#ifdef SUPPORT_GUSTURE	atomic_set(&double_tap_number,0);	atomic_set(&double_tap_enable,1);	atomic_set(&circle_gesture_number,0);	atomic_set(&circle_gesture_enable,1);	atomic_set(&gusture_enable, 1);#endif	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {		TPDTM_DMESG("synaptics_ts_probe: need I2C_FUNC_I2C\n");		ret = -ENODEV;		goto err_check_functionality_failed;	}	init_synaptics_proc();    ret = i2c_smbus_read_byte_data(client,0x13);	if(ret < 0)	{		ret = i2c_smbus_read_byte_data(client,0x13);		if(ret < 0)		{			tpd_power(0);			printk("synaptics is no exist!\n");			return 0;		}	}	ts = kzalloc(sizeof(*ts), GFP_KERNEL);	if (ts == NULL) {		ret = -ENOMEM;		goto err_alloc_data_failed;	}	memset(ts,0,sizeof(*ts));//	tp_autotest = kzalloc(sizeof(*tp_autotest), GFP_KERNEL);//	memset(tp_autotest,0,sizeof(*tp_autotest));	/*check tp factory*/	get_tp_id();			//tp_dev = TP_TRULY;	INIT_WORK(&ts->work, synaptics_ts_work_func);	ts->client = client;	i2c_set_clientdata(client, ts);	synaptics_read_register_map(ts);	bootloader_mode = i2c_smbus_read_byte_data(ts->client,F01_RMI_DATA_BASE);	bootloader_mode = bootloader_mode&0xff;	bootloader_mode = bootloader_mode&0x40; 	printk("synaptics:before fw update,bootloader_mode = 0x%x\n",bootloader_mode);		i2c_smbus_read_i2c_block_data(ts->client, F34_FLASH_CTRL00, 4, buf); 	CURRENT_FIRMWARE_ID = (buf[0]<<24)|(buf[1]<<16)|(buf[2]<<8)|buf[3];	printk("CURRENT_FIRMWARE_ID = 0x%x\n",CURRENT_FIRMWARE_ID);		TP_FW = CURRENT_FIRMWARE_ID;	if(tp_dev == TP_TRULY){		printk("TP_DEV = TP_TRULY\n");	buf[0]=TRULY_Config_Data[0][0];	buf[1]= TRULY_Config_Data[0][1];	buf[2]= TRULY_Config_Data[0][2];	buf[3]=TRULY_Config_Data[0][3];	FIRMWARE_ID_TRULY = (buf[0]<<24)|(buf[1]<<16)|(buf[2]<<8)|buf[3];		printk("read firmware ID: CURRENT_FIRMWARE_ID = %x,LOCAL_FIRMWARE_ID = %x\n",CURRENT_FIRMWARE_ID,FIRMWARE_ID_TRULY);	}		if(tp_dev == TP_TPK){		printk("TP_DEV = TP_TPK\n");	buf[0]=TPK_Config_Data[0][0];	buf[1]= TPK_Config_Data[0][1];	buf[2]= TPK_Config_Data[0][2];	buf[3]=TPK_Config_Data[0][3];	FIRMWARE_ID_TPK = (buf[0]<<24)|(buf[1]<<16)|(buf[2]<<8)|buf[3];		printk("read TPK firmware ID: CURRENT_FIRMWARE_ID = %x,LOCAL_FIRMWARE_ID = %x\n",CURRENT_FIRMWARE_ID,FIRMWARE_ID_TRULY);	}	/*	else	{		printk("check TP type erro!!!!!!!!!\n");			//	goto synaptics_ts_probe_end;	}	*/	if(boot_mode == NORMAL_BOOT)	{	   	    printk("synaptics_ts_probe:FW update start... \n");		if(tp_dev == TP_TRULY)		{			if(CURRENT_FIRMWARE_ID == FIRMWARE_ID_TRULY)			{				printk("CURRENT_FIRMWARE_ID = 0x%x,FIRMWARE_ID_TRULY = 0x%x/n",CURRENT_FIRMWARE_ID,FIRMWARE_ID_TRULY);		   		goto after_fw_update;			}												}		if(tp_dev == TP_TPK)		{			if(CURRENT_FIRMWARE_ID == FIRMWARE_ID_TPK)			{				printk("CURRENT_FIRMWARE_ID = 0x%x,FIRMWARE_ID_TRULY = 0x%x/n",CURRENT_FIRMWARE_ID,FIRMWARE_ID_TRULY);		   		goto after_fw_update;			}												}			/*	else		{		   			    goto after_fw_update;						}	*/ fw_update:	 		synatpitcs_ts_update(ts->client);  			synaptics_read_register_map(ts); 		i2c_smbus_read_i2c_block_data(ts->client, F34_FLASH_CTRL00, 4, buf);  		CURRENT_FIRMWARE_ID = (buf[0]<<24)|(buf[1]<<16)|(buf[2]<<8)|buf[3];	 		fw_cnt++; 		printk("after FW upate times fw_cnt = %d\n\ 			, CURRENT_FIRMWARE_ID2 = %x,\n",fw_cnt,CURRENT_FIRMWARE_ID); 	    TP_FW=CURRENT_FIRMWARE_ID;    }		after_fw_update:	/*disable interrupt*/	ret = synaptics_enable_interrupt(ts, 0);	if(ret < 0) {		TPDTM_DMESG(" synaptics_ts_probe: disable interrupt failed\n");	}		/*read product id */	ret = synaptics_read_product_id(ts);	if(ret) {		TPDTM_DMESG("failed to read product info \n");	}   	/*read max_x ,max_y*/	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x0);	if (ret < 0) {		TPDTM_DMESG("i2c_smbus_write_byte_data failed for page select\n");	}#ifdef SUPPORT_GUSTURE	if(tp_dev == TP_TPK)	{	 ret = i2c_smbus_read_word_data(ts->client, 0x84);	 TPDTM_DMESG("synaptics check gesture enable Reg bit0 and bit3 0x84 = 0x%x\n",ret);	}#endif		ret = i2c_smbus_read_word_data(ts->client, F11_2D_CTRL06);    if(ret > 0)	    ts->max_x = ret&0xffff;           ret = i2c_smbus_read_word_data(ts->client, F11_2D_CTRL08);    if(ret > 0)	    ts->max_y = ret&0xffff;	    	TPDTM_DMESG("max_x = %d,max_y = %d\n",ts->max_x,ts->max_y);	bootloader_mode = i2c_smbus_read_byte_data(ts->client,F01_RMI_DATA_BASE);	bootloader_mode = bootloader_mode&0xff;	bootloader_mode = bootloader_mode&0x40; 		TPDTM_DMESG("synaptics:afte fw update,bootloader_mode = 0x%x\n",bootloader_mode);		TPDTM_DMESG("synaptics max_x = %d\n max_y = %d\n",ts->max_x,ts->max_y); 	if((ts->max_x == 0)||(ts->max_y == 0)||(bootloader_mode == 0x40)){		if(fw_cnt < 2)		printk("hehe  jiushi bushengji");		goto fw_update;	}		ts->input_dev = input_allocate_device();	if (ts->input_dev == NULL) 	{		ret = -ENOMEM;		printk(KERN_ERR "synaptics_ts_probe: Failed to allocate input device\n");		goto err_input_dev_alloc_failed;	}	ts->input_dev->name = TPD_DEVICE;;	set_bit(EV_SYN, ts->input_dev->evbit);	set_bit(EV_ABS, ts->input_dev->evbit);	set_bit(EV_KEY, ts->input_dev->evbit);	set_bit(ABS_MT_TOUCH_MAJOR, ts->input_dev->absbit);	set_bit(ABS_MT_WIDTH_MAJOR,ts->input_dev->absbit);	set_bit(ABS_MT_POSITION_X, ts->input_dev->absbit);	set_bit(ABS_MT_POSITION_Y, ts->input_dev->absbit);	set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);#ifdef SUPPORT_GUSTURE	set_bit(KEY_POWER, ts->input_dev->keybit);#endif		/* For multi touch */	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR,			     0, 255, 0, 0);		input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X,					 0, ts->max_x, 0, 0);	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y,					 0,ts->max_y - 115, 0, 0);				set_bit(BTN_TOUCH, ts->input_dev->keybit);	set_bit(KEY_SEARCH, ts->input_dev->keybit);	set_bit(KEY_MENU, ts->input_dev->keybit);	set_bit(KEY_HOME, ts->input_dev->keybit);	set_bit(KEY_BACK, ts->input_dev->keybit);	input_set_drvdata(ts->input_dev, ts);		if(input_register_device(ts->input_dev))	{		printk(KERN_ERR "synaptics_ts_probe: Failed to register input device\n");		goto err_input_dev_register;	}    synaptics_tpd_button_init(ts);#ifdef TPD_USE_EINT	ts_g = ts;	mt_set_gpio_mode(TOUCHPANEL_INT_PIN, GPIO_MODE_01);	mt_set_gpio_dir(TOUCHPANEL_INT_PIN,GPIO_DIR_IN);	mt_set_gpio_pull_enable(TOUCHPANEL_INT_PIN, GPIO_PULL_ENABLE);	mt_set_gpio_pull_select(TOUCHPANEL_INT_PIN, GPIO_PULL_UP);	mt65xx_eint_set_polarity(CUST_EINT_TOUCH_PANEL_NUM,CUST_EINT_POLARITY_LOW);	mt65xx_eint_set_sens(CUST_EINT_TOUCH_PANEL_NUM,		CUST_EINT_LEVEL_SENSITIVE);//level low pull up	mt65xx_eint_set_hw_debounce(CUST_EINT_TOUCH_PANEL_NUM, 			(CUST_EINT_TOUCH_PANEL_DEBOUNCE_CN >> 4));	mt65xx_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, 					CUST_EINT_DEBOUNCE_DISABLE, 					CUST_EINT_POLARITY_LOW, 					synaptics_ts_irq_handler, 					0);			mt65xx_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);	ret = synaptics_enable_interrupt(ts, 1);		if(ret) {		TPDTM_DMESG("synaptics_ts_probe: failed to enable synaptics  interrupt \n");		free_irq(client->irq, ts);		goto err_power_failed;	}		/*config tm1429: set report rate, sleep mode */	ret = synaptics_init_panel(ts); /* will also switch back to page 0x04 */	if (ret < 0) {		TPDTM_DMESG("synaptics_init_panel failed\n");		}	ts->use_irq = 1;#else	hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);	ts->timer.function = synaptics_ts_timer_func;	hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);#endif#ifdef CONFIG_HAS_EARLYSUSPEND	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;	ts->early_suspend.suspend = synaptics_ts_early_suspend;	ts->early_suspend.resume = synaptics_ts_late_resume;	register_early_suspend(&ts->early_suspend);#endif		if (driver_create_file(&synaptics_driver.driver, &driver_attr_oppo_tp_debug))	{            		TPDTM_DMESG("driver_create_file failt\n");		goto exit_init_failed;	}  		if (driver_create_file(&synaptics_driver.driver, &driver_attr_oppo_tp_test))	{           		TPDTM_DMESG("driver_create_file failt\n");				goto exit_init_failed;		}	if (driver_create_file(&synaptics_driver.driver, &driver_attr_oppo_tp_delta_image))	{            		TPDTM_DMESG("driver_create_file failt\n");		goto exit_init_failed;	}#ifdef SUPPORT_GUSTURE	if (driver_create_file(&synaptics_driver.driver, &driver_attr_oppo_tp_double_tap_num))	{		TPDTM_DMESG("driver_create_file fail\n");		goto exit_init_failed;	}		if (driver_create_file(&synaptics_driver.driver, &driver_attr_oppo_tp_double_tap_enable))	{		TPDTM_DMESG("driver_creat_file fail\n");		goto exit_init_failed;	}#endif	return 0;exit_init_failed:err_detect_failed:err_power_failed:	input_unregister_device(ts->input_dev);err_input_dev_register:	input_free_device(ts->input_dev);err_input_dev_alloc_failed:	kfree(ts);err_alloc_data_failed:err_check_functionality_failed:synaptics_ts_probe_end:#ifdef OPPO_R819//hsy@oppo.com, add 2011/12/14 for tpd power off		#ifndef SUPPORT_GUSTURE		tpd_power(0);	#else		if (1 == atomic_read(&double_tap_enable))		{	   //null		}		else		{		   tpd_power(0);		}	#endif#endif/*OPPO_R819*/	return ret;}static int synaptics_ts_remove(struct i2c_client *client){	struct synaptics_ts_data *ts = i2c_get_clientdata(client);#ifdef CONFIG_HAS_EARLYSUSPEND	unregister_early_suspend(&ts->early_suspend);#endif	#ifdef TPD_USE_EINT		mt65xx_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);#else		hrtimer_cancel(&ts->timer);#endif		input_unregister_device(ts->input_dev);	input_free_device(ts->input_dev);	kfree(ts);    tpd_hw_pwroff();	return 0;}static int synaptics_ts_suspend(struct i2c_client *client, pm_message_t mesg){	int ret;	uint8_t d;	struct synaptics_ts_data *ts = i2c_get_clientdata(client);	printk("synaptics_ts_suspend is called\n");    is_suspend = 1;	lm3528_check_tpsuspend = 1;#ifdef TPD_USE_EINT	mt65xx_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);#else	hrtimer_cancel(&ts->timer);#endif	ret = synaptics_enable_interrupt(ts, 0);	if(ret) {		TPDTM_DMESG("synaptics_ts_suspend: cannot disable interrupt\n");		return -1;	}	ret = cancel_work_sync(&ts->work);	if(ret) {		TPDTM_DMESG("synaptics_ts_suspend: cannot disable work\n");	}	ret = synaptics_enable_interrupt(ts, 0);	if(ret) {		TPDTM_DMESG("synaptics_ts_suspend: can not disable \		    synaptics_enable_interrupt\n");	}		ret = i2c_smbus_write_byte_data(client, F01_RMI_CTRL00, 0x01); 	if (ret < 0) {		TPDTM_DMESG("synaptics_ts_suspend: control tm1400 to sleep failed\n");		return -1;	}		return 0;}static int synaptics_ts_resume(struct i2c_client *client){	int ret;	struct synaptics_ts_data *ts = i2c_get_clientdata(client);	printk("synaptics_ts_resume is called\n");	if (!ts->use_irq) {		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);	} else {        synaptics_init_panel(ts);		if (ret < 0) {			TPDTM_DMESG("synaptics_ts_resume: control tm1400 to sleep failed\n");			return -1;		}		        is_suspend = 0;		lm3528_check_tpsuspend = 0;		#ifdef TPD_USE_EINT		mt65xx_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);    #endif		ret = synaptics_enable_interrupt(ts, 1);		if(ret) {			TPDTM_DMESG("synaptics_ts_resume:cannot  enable interrupt \n");			return -1;		}    	}	return 0;}/*----------------------------------------------------------------------------*/#ifdef CONFIG_HAS_EARLYSUSPENDstatic void synaptics_ts_early_suspend(struct early_suspend *h){	printk("synaptics_ts_early_suspend is called\n");	struct synaptics_ts_data *ts;	ts = container_of(h, struct synaptics_ts_data, early_suspend);	int ret = -1;#ifdef SUPPORT_GUSTURE    /*ret = i2c_smbus_write_byte_data(ts->client, F11_2D_CTRL32, 0x9a);	if(ret < 0) {		TPD_DEBUG("write reg F11_2D_CTRL32 failed\n");		return -1;	}		ret = i2c_smbus_read_byte_data(ts->client, F11_2D_CTRL32);	TPD_DEBUG("read reg F11_2D_CTRL32=%x \n",ret);	if(ret < 0) {		TPD_DEBUG("read reg F11_2D_CTRL32 failed\n");		return -1;	}	*/	    if (1 == atomic_read(&gusture_enable)){	    synaptics_enable_interrupt_for_gusture(ts, 1);	    return;	    }#endif			synaptics_ts_suspend(ts->client, PMSG_SUSPEND);#ifdef OPPO_R819//hsy@oppo.com, add 2011/12/14 for tp power off     //tpd_power(0);	#ifndef SUPPORT_GUSTURE	tpd_power(0);	#else	if (1 == atomic_read(&gusture_enable))	{		TPDTM_DMESG("synaptic do not call tpd_power(0)\n");	    //null	}	else	{	   tpd_power(0);	}	#endif		 	 	printk("read_gusture is %x\n",read_gusture);#endif/*OPPO_R819*/}static void synaptics_ts_late_resume(struct early_suspend *h){	printk("synaptics_ts_late_resume is called\n");	struct synaptics_ts_data *ts;	ts = container_of(h, struct synaptics_ts_data, early_suspend);		int ret = -1;	get_tp_id();#ifdef SUPPORT_GUSTURE/*	ret = i2c_smbus_write_byte_data(ts->client, F11_2D_CTRL32, 0x2b);	if(ret < 0) {		printk("wjw tp write reg F11_2D_CTRL32 failed\n");		return -1;	}		ret = i2c_smbus_read_byte_data(ts->client, F11_2D_CTRL32);	printk("read reg F11_2D_CTRL32=%x \n",ret);	if(ret < 0) {		printk("read reg F11_2D_CTRL32 failed\n");		return -1;	}	*/    if (1 == atomic_read(&gusture_enable)) {		synaptics_enable_interrupt_for_gusture(ts, 0);     }#endif		#ifdef OPPO_R819//hsy@oppo.com, add 2011/12/14 for tpd power off	#ifndef SUPPORT_GUSTURE	tpd_power(1);	#else	if (1 == atomic_read(&gusture_enable))	{		TPDTM_DMESG("synaptic do not call tpd_power(1)");	   //null	}	else	{	  tpd_power(1);		}	#endif#endif/*OPPO_R819*///	synaptics_ts_resume(ts->client);	ret = i2c_smbus_read_byte_data(ts->client, F01_RMI_DATA_BASE);	printk("F01_RMI_DATA_BASE in the resume is %x\n",ret);	ret = i2c_smbus_write_byte_data(ts->client, F01_RMI_CMD_BASE,0x01);		TPDTM_DMESG("synaptic TP is reseting\n");		msleep(150);		synaptics_ts_resume(ts->client);	printk("read_gusture is %x\n",read_gusture);}#endif/*----------------------------------------------------------------------------*/static const struct i2c_device_id synaptics_ts_id[] = {	{ TPD_DEVICE, 0 },	{ }};static struct i2c_board_info __initdata i2c_tpd={ I2C_BOARD_INFO(TPD_DEVICE, (0x40>>1))};/*static unsigned short synaptics_force[] = {0x00, 0xE0,     I2C_CLIENT_END, I2C_CLIENT_END};static const unsigned short *const synaptics_forces[] = { synaptics_force,    NULL };static struct i2c_client_address_data synaptics_addr_data = {     .forces = synaptics_forces,    };*//*----------------------------------------------------------------------------*/static int synaptics_ts_detect(struct i2c_client *client,    int kind, struct i2c_board_info *info){             strcpy(info->type, TPD_DEVICE);                                                         	TPDTM_DMESG("synaptics-rmi-ts driver_detect !!\n ");	    return 0;                                                                                       }/*----------------------------------------------------------------------------*/static struct i2c_driver tpd_i2c_driver = {	.probe		= synaptics_ts_probe,	.remove		= synaptics_ts_remove,//	.detect         = synaptics_ts_detect,                           #ifndef CONFIG_HAS_EARLYSUSPEND	.suspend	= synaptics_ts_suspend,	.resume		= synaptics_ts_resume,#endif	.id_table	= synaptics_ts_id,//	.address_data = &synaptics_addr_data,	.driver = {//		.owner    = THIS_MODULE,		.name	= TPD_DEVICE,	},};static int synaptics_probe(struct platform_device *pdev) {	boot_mode = get_boot_mode();	printk("boot_mode = %d ............\n",boot_mode);	// Software reset mode will be treated as normal boot	if(boot_mode==3) boot_mode = NORMAL_BOOT;    synaptics_wq = create_singlethread_workqueue("synaptics_wq");    if (!synaptics_wq) {        return -ENOMEM;    }       if(i2c_add_driver(&tpd_i2c_driver)!=0) {        TPDTM_DMESG("unable to add i2c driver.\n");        return -1;    }	    return 0;}static int synaptics_remove(struct platform_device *pdev){	i2c_del_driver(&tpd_i2c_driver);	if (synaptics_wq)		destroy_workqueue(synaptics_wq);}/* called when loaded into kernel */static int __init tpd_driver_init(void) {   i2c_register_board_info(0, &i2c_tpd, 1);   	if(platform_driver_register(&synaptics_driver)!=0) {		printk("unable to register touch panel driver.\n");		return -1;	}		return 0;}/* should never be called */static void __exit tpd_driver_exit(void) {  platform_driver_unregister(&synaptics_driver);}module_init(tpd_driver_init);module_exit(tpd_driver_exit);MODULE_DESCRIPTION("Synaptics Touchscreen Driver");MODULE_LICENSE("GPL");